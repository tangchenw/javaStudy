# Java基础

**JDK、JRE、JVM三者之间的关系：**

JDK：Java开发工具箱

JRE：java运行环境

JVM：java虚拟机（C++程序编写的虚拟计算机）

> JDK包括JRE、JRE包括JVM。JVM不能独立安装，其它两个都有安装包可以独立安装,Java程序员直接编写的Java代码（普通文本）是无法执行被JVM识别的。Java程序员编写的Java代码这种普通文本必须经过一个编译，将这个普通文本代码编程字节码，JVM能够识别字节码。Java代码这种普通文本编程字节码的过程，被称为：编译。

JVM中以栈内存、方法区、堆内存为主要存储区。

## Java类加载器

JVM会调用类加载器classloader

**类加载器：**负责去找类对应的字节码文件，类加载器找到了对应的字节码文件将该文件装载到JVM中，JVM启动解释器将字节码解释为二进制码，操作系统执行二进制码和硬件交互

> classpath环境变量的配置是为了给类加载器一个初始路径去找字节码文件(class)的

JDK中的JAVADOC.EXE程序可以识别

/**
*
*/注释，可以自动被javadoc.exe命令解析提取并生成到帮助文档中（javadoc -d javaapi(文件夹)）

## java基础知识点

- public修饰的类名必须和源文件名保持一致

- 计算机中整型数据以反码的形式进行存储，要求源码，需要减一后取反得到源码

- byte char short作混合运算时，必须都先转换成Int型再进行运算

- 多种数据类型做混合运算的时候，最终的结果类型是最大容量对应的类型（char+short+byte除外，会各自转换成Int类型进行运算）

- 浮点型float和double在银行方面的使用是远远不够的，精度更高的类型专门用在财务软件方面java.math.BigDecimal

> BigDecimal不止是精度更高，而且不会造成精度丢失的问题。

- float类型比long类型容量大，（任何一个浮点型都比整数型空间大）
- 方法重载和返回值类型与修饰符无关（即修饰符不同或者修饰符列表不同参数相同方法名相同认为是同一方法)

**面向对象的三大特征：**封装、继承、多态

堆内存：凡是通过new运算符创建的对象，都存储在堆内存当中。new运算符的作用就是在堆内存中开辟一块空间
Java中的垃圾回收器GC主要针对回收的是堆内存当中的垃圾数据

带static的方法用类名.方法去调用，不带static的方法（实例方法）先根据类的构造方法创建引用，然后通过引用去调用

## java中专业术语

**OOA:面向对象分析**
**OOD：面向对象设计**
**OOP:面向对象编程**

## Java异常

Object下有**Throwable**（可抛出的）（所有异常的父类最高级父类）

Throwable下有两个分支：**Error**（不可处理，直接退出JVM）和**Exception**(可处理的)

Exception下有两个分支：

Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，不处理就会在编译时报错）
RuntimeException:运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）

编译时异常和运行时异常，都是发生在运行阶段，编译阶段异常时不会发生的。

编译时异常因为什么而得名？
因为编译时异常必须在编译阶段预先处理，如果不处理编译器报错，因此得名。

**编译时异常**：受检异常、受控异常
**运行时异常**：未受检异常、非受控异常

Java对异常的处理包括两种方式：

- 在方法声明的位置上，使用throws关键字，抛给上一级。
- 使用try...catch语句进行异常的捕捉。

**try...catch**
1.catch后面小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。
2.catch可以写多个。建议catch的时候，精确的一个一个处理。这样有利于程序的调试。
3.catch写多个的时候，从上到下，必须遵守从小到大。

jdk8的新特性，异常后面可以加或运算符。

**try...catch中的finall子句：**
1.在finally子句中的代码时最后执行的，并且时一定会执行的，即使try语句块中的代码出现了异常
finally子句必须和try一起出现，不能单独编写。

**final finally finalize之间的区别：**

- final是一个关键字，表示最终的，不变的。
- finally也是一个关键字，和try联合使用，使用在异常处理机制中，finally语句块中的代码是一定会执行的。
- finalize()是Object类中的一个方法。作为方法名出现。所以finalize是标识符。

throws 在方法声明位置上使用，表示上报异常信息给调用者。
throw 手动抛出异常！

## 集合

数组其实就是一个集合，集合实际上就是一个容器，可以来容纳其它类型的数据。

集合为什么说在开发中使用较多？

集合是一个容器，是一个载体，可以一次容纳多个对象。

> 集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）
>
> 集合在任何时候存储的都是“引用”

在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。

要求只需要掌握怎么用？在什么情况下选择哪一种合适的集合去使用即可。

new ArrayList(); 创建一个集合，底层是数组。
new LinkedList（）；创建一个集合对象，底层是链表。
new TreeSet（）；创建一个集合对象，底层是二叉树。

### 在java中集合分为两大类：

- 单个方式存储元素，这一类集合中超级父接口：java.util.Collection;
- 以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;

Iterator it="Collection 对象".iterator(); 迭代器对象

**总结**

- ArrayList:底层是数组，非线程安全
- LinkedList：底层是双向链表，非线程安全
- Vector：底层是数组，线程是安全的，方法用syn...修饰，效率较低
- HashSet：底层是Hashmap，放到HashSet集合中的元素等同放到HashMap集合的Key部分了。初始化容量16，初始化容量建议2的倍数，扩容之后是原容量2倍。
- TreeSet:底层是TreeMap，放到TreeSet集合中的元素等同于放到TreeMap集合Key部分了。
- HashMap：底层是哈希表。初始化容量16，初始化容量建议2的倍数，扩容之后是原容量2倍。（后面追加了线程安全的ConcurrentHashMap）
- Hashtable：底层是哈希表。线程安全的，效率较低，使用比较少。初始化容量11，默认加载因子是0.75，扩容之后是原容量2倍
- Properties：线程安全的，并且Key和Value只能存储字符串String。
- TreeMap：底层是（红黑树）二叉树？TreeMap集合中Key可以自动按照大小顺序排序。

**List集合和Map集合各自的优缺点：**

List集合存储元素的特点：有序可重复（指存进去是什么，取出来就是什么，存进去1，可以再存储一个1）
Set集合存储元素的特点：无序不可重复（存进去的顺序和取出的顺序不一定相同。Set集合中元素没有下标。存进去1，不能再存储1了）
SortedSet集合存储元素的特点：无需不可重复的，但是SortedSet集合中的元素是可排序的（可以按照大小顺序排列）

**遍历集合元素的实话不应该对集合本身的元素进行增删操作**

> 当调用集合对象的删除元素方法删除元素之后，集合的结构发生了变化，应该重新去获取迭代器
> 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常。
> 但是使用迭代器中的删除元素功能则可以进行删除迭代器指向的当前元素。

#### 数组

特点：

- 检索效率比较高。
- 数组无法存储大数据量（很难找到一块非常巨大的连续的内存空间）
- 随机增删元素效率比较低。向数组末尾添加元素效率还是很高的。

#### 链表

对于链表数据结构来说：基本单元是节点Node。

对于单项链表来说，任何一个节点Node中都有两个属性，一个是存储的数据，一个是下一个节点的内存地址。

特点：

- 随机增删元素效率较高。（因为增删元素不设计到大量元素的位移）
- 查询效率较低，每一次查找某个元素的时候都需要从头节点开始往下遍历。

> LinkedList集合底层也是有下标的

#### 哈希表

HashMap集合的默认初始化容量是16，默认加载因子是0.75（这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。）

放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要重写hashCode和euals方法。

>重点：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的，这是因为达到散列均匀，为了
>提高HashMap集合的存取效率所必须的。

HashMap在jdk8之后，如果哈希表单向链表中元素超过8个，单向链表这种数组结构会变成红黑树这种数据结构，当红黑树
上数据节点小于6时，会把红黑树变成单向链表数据结构。（二叉树的检索效率较高。）

#### HashTable

Hashtable的key和value的值都不能为空，有一个为空就会报空指针异常。（hashtable带有synchronized：线程安全的，
线程安全有其它方案，hashtable对相乘的处理导致效率比较低使用的比较少了）

Hashmap集合的Key和value都是可以为空null的。
Hashtable的初始化容量是11，默认加载因子是0.75.扩容是原容量乘以2再加一

#### Tree

Tree集合底层实际上是一个TreeMap;Tree集合底层是一个二叉树

放到TreeSet集合中的元素，等同于放到TreeMap集合的Key部分了。

Tree集合中的元素，无序不可重复，但是可以按照元素的大小进行排序。

自定义类型，Tree无法排序。只要自定义的类没有实现comparable接口，就无法实现强制类型转换进行比较，从而无法实现排序。

compareTo方法的返回值很重要：返回0表示相同，value会覆盖。返回>0，会继续在右子树上找。返回<0,会继续在左子树上找。

自平衡二叉树。遵循左小右大的原则存放。

遍历二叉树的时候有三种方式：前序遍历：根左右；中序遍历：左根右；后序遍历：左右根
TreeSet集合/TreeMap集合采用的是：中序遍历方式。Iterator迭代器采用的是中序遍历的方式。（左根中）

TreeSet或者TreeMap集合key部分的元素想要做到排序，包括两种方式：
第一种：放在集合中的元素实现java.lang.Comparable接口
第二种：在构造TreeSet或者TreeMap集合的时候给它穿一个比较器对象。

如何选择呢？当比较规则不会发生改变的时候，或者说当比较规则只有一个的时候，建议实现Comparable接口
当比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。

## java泛型

泛型的优点：集合中存储的元素类型统一了。从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”
泛型的缺点：导致集合中存储的元素缺乏多样性！

自定义泛型的时候，<>尖括号是一个标识符，随便写。如果不使用泛型则默认是Object类型

## Java流

IO流：通过IO可以完成硬盘文件的读和写

**IO流的分类**

1. 流的方向进行分类
   - 往内存中去，叫做输入。或者叫读。
   - 从内存中出来，叫做输出。或者叫做写。

2. 按照读取数据方式的不同进行分类
   - 有的流是按照字节的方式读取数据，一次读取1个字节byte,等同于一次读取8个二进制，这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件。
   - 有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件存在的，这种流不能读取：图片、声音、视频等文件。只能读取纯文本文件，连word文件都无法读取。

**java IO流的四大家族：**

- java.io.InputStream 字节输入流
- java.io.OutputStream 字节输出流
- java.io.Reader 字符输入流
- java.io.Writer 字符输出流

>四大家族的首领都是 public abstarct 抽象类，所有的流都实现了：java.io.closeable接口，都是可关闭的，都有cloase()方法。
>java中只要类名以steam结尾的都是字节流，只要以Reader/Writer结尾的都是字符流
>
>所有的输出流都实现了:java.io.Flushable接口，都是可刷新的，都有flush()方法。养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下，这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道！）刷新的作用就是清空管道。
>注意：如果没有flush()可能会导致丢失数据。

#### 序列化与反序列化

在IDEA的默认当前路径是工程project的根。
内存中的java对象传送到硬盘文件当中的过程叫做序列化（拆分对象）
而硬盘文件中的java对象（数据信息）传送到内存中的过程叫做反序列化（组装对象）

序列化：Serialize（ObjectOutputStream) 	反序列化：DeSerialize(ObjectInputStream)

参与序列化的对象需要实现Serializable接口
序列化多个对象，创建一个list集合，往集合中存放多个对象就行
不希望对象的某些属性参与序列化时可以使用transient关键字表示游离的，不参与序列化。

## 多线程

**什么是进程？什么是线程？**

进程是应用程序。
线程是一个进程中的执行场景/执行单元。

一个进程可以启动多个线程

线程A和线程B，在堆内存和方法区内存共享。
但是栈内存独立，一个线程一个栈。

问题：对于单核的cpu来说，真的可以做到真正的多线程并发吗？
对于多核的cpu电脑来说，真正的多线程并发是没有问题的。

**什么是真正的多线程并发？**
t1线程执行t1的
t2线程执行t2的。
t1不会影响t2，t2也不会影响t1.这叫做真正的多线程并发。
单核的cpu：不能够做到真正的多线程并发，但是可以做到给人一种多线程并发的感觉。

**Java中实现线程有两种方式：**

java支持多线程机制，并且java已经将多线程实现了。我们只需要继承就行了。

第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。
亘古不变：方法体中的代码永远都是自上而下的顺序依次逐行执行的。
第二种方式：编写一个类，实现java.lang.Runnable接口，实现run方法。

**常见的线程调度模型有哪些？**

抢占式调度模型：
哪个线程的优先级比较高，抢到的CPU时间的概率就高一些/多一些。java采用的就是抢占式调度模型。

均分式调度模型：
平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。平均分配，一切平等。

有些编程语言，线程调度模型采用的式这种方式。

**关于多线程并发环境下，数据的安全问题。**

以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了，这些代码我们都不需要编写。

**最重要的是**：我们所编写的程序需要放到一个多线程的环境下运行，更需要关注的是这些数据在多线程并发的环境下是否是安全的。

局部变量永远都不会存在线程安全问题，因为局部变量不共享。（一个线程一个栈）
局部变量在栈中。所以局部变量永远不会共享。

实例变量在堆中，堆只有一个。

静态变量在方法区中，方法区只有一个。

堆和方法区都是多线程共享的，所以可能存在线程安全问题。

在实例方法上可以使用synchronized，对象锁锁的一定是this，（当前对象）
在静态方法上面使用synchronized，表示找类锁。类锁永远只有1把，就算创建了100个对象，那类锁也只有一把。

对象锁：一个对象一把锁，100个对象100把锁。

**以后开发中应该如何解决线程安全问题？**
不应该一上来就选择线程同步（synchronized)synchronized会让程序的执行效率降低，用户体验不好。
系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择线程同步。

第一种方案：尽量使用局部变量代替“实例变量和静态变量”
第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。（一个线程一个对象，100个线程对应100个对象，
对象不共享，就没有数据安全问题了。）
第二种方案：如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了。线程同步机制。

### 线程的分类

java中线程分为两大类：

- 用户线程
- 守护线程（后台线程）具有代表性的就是：垃圾回收线程

守护线程的特点：一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。t.setDaemon(true)设置某个线程为守护线程。

实现线程的第三种方式：实现Callable接口。（JDK8新特性）

这种方式实现的线程可以获取线程的返回值。
之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。

这种方式的优点：可以获取到线程的执行结果。
这种方式的缺点：效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。

### Object类中的wait和notify方法

第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为着两个方法时Object类自带的。
第二：wait方法的作用

```java
Object o=new Object();
o.wait();
//表示：让正在o对象上活动的贤臣刚进入等待状态，无期限等待，直到被唤醒为止。
//o.wait（）;方法的调用，会让当前线程（正在O对象上活动的线程）进入等待状态。
```

第三：notify()方法的作用
表示：唤醒正在o对象上等待的线程。
还有一个NotifyAll()方法：这个方法是唤醒o对象上处于等待的所有线程。
wait方法和Notify方法建立在线程同步的基础之上，因为多线程要同时操作一个对象，有线程安全问题。



## 反射机制

**反射机制有什么用？**

通过java语言中的反射机制可以操作字节码文件。优点类似于黑客。（可以读和修改字节码文件。）

**反射机制相关的类在哪个包下？**

java.lang.reflect.*

**反射机制相关的类有哪些？**

java.lang.Class:代表字节码文件
java.lang.reflect.Method：代表字节码中的方法字节码。
java.lang.reflect.Constructor：代表字节码中的构造方法字节码。
java.lang.reflect.Field：代码字节码中的属性字节码。

#### 类加载器

**什么是类加载器？**

专门负责加载类的命令/工具。ClassLoader
JDK中自带了三个类加载器

- 启动类加载器
- 扩展类加载器
- 应用类记载器

假设有这样一段代码：
`String s="abc";`

代码在开始执行之前，会将所需要的类全部加载到JVM当中。
通过类加载器加载，看到以上代码类加载器会找到String.class文件，找到就加载，那么是怎么进行加载的呢？

首先通过“启动类加载器”加载。
启动类加载器专门加载：rt.jar包
rt.jar中都是JDK最核心的类库。
如果通过“启动类加载器”加载不到的时候，会通过“扩展类加载器”加载。

扩展类加载器专门加载：ext\*.jar包
如果扩展类加载器没有加载到，那么会通过应用类加载器加载。
应用类加载器专门加载：classpath中的类

java中为了保证类加载的安全，使用了双亲委派机制。
优先从启动类加载器中加载，这个称为父，父无法加载到，再从扩展类加载器中加载。
这个称为母。双亲委派。如果都加载不到，才会考虑从应用类加载器中加载。直到加载到为止。

## 注解

注解Annotation是一种引用数据类型，编写之后也是生成xxx.class文件

怎么自定义注解呢？

```java
[修饰符列表] @interface 注解类型名{}
```

**注解怎么使用，用在什么地方？**

第一：注解使用时的语法格式是：
	@注解类型名
第二：注解可以出现在类上、属性上、方法上、变量上等...

**JDK内置注解**

- Deprecated 用这个注解程序元素，但是不鼓励程序员使用这样的元素
- Override 表示一个方法声明打算重写父类中的另外一个方法声明
- SuppressWarnings(不要求掌握)
- Override这个注解只能注解方法。这个注解给编译器参考的，和运行没有关系。

**元注解**：用来标注“注解类型”的注解，称为元注解

常见的元注解：Target,Retention

**关于Target注解**：这个注解用来标注“被标注的注解”可以出现在哪些位置上。
关于Retention注解：@Retention(RetentionPolicy.SOURCE)表示该注解只被保留在java源文件当中。
@Retention(RetentionPolicy.CLASS)表示该注解被保留在class文件中
@Retention(RetentionPolicy.RUNTIME)表示该注解被保存在class文件中，并且可以被反射机制所读取到

**Deprecated**标记的元素表示某个元素已经过时（标记类类过时，标记方法方法过时）这个注解主要是向其它程序员传递一个信息，
告知已过时，有更好的解决方案存在。
注解的属性只有一个value时可以省略不写value。
注解当中属性的类型可以是八大基本数据类型和String class 枚举类型以及它们的数组形式