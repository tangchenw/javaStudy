# 定时任务解决方案和比较

## JDK解决方案TimeTask

**Timer和TimerTask**

Timer是jdk中提供的一个定时器工具，使用的时候会在主线程之外起一个单独的线程执行指定的计划任务，可以指定执行一次或者反复执行多次。TimerTask是一个实现了Runnable接口的抽象类，代表一个可以被Timer执行的任务。

## Spring解决方案spring schedule（springTask)

- 一、如何使用定时任务
  - 1、启动类使用@EnableScheduling注解开启定时任务
  - 2、方法使用@Scheduled注解，或者实现SchedulingConfigurer接口，添加定时任务
- 二、配置定时任务多线程非阻塞运行
  - 1、阻塞原因
  - 2、如何解决，实现SchedulingConfigurer接口，设置任务调度器实现类

## 开源框架Quartz

**Quartz是一套轻量级的任务调度框架，只需要定义了 Job（任务），Trigger（触发器）和 Scheduler（调度器），即可实现一个定时调度能力。支持基于数据库的集群模式，可以做到任务幂等执行。**

## 三者的比较

| 实现方式        | cron表达式 | 固定时间执行 | 固定频率执行 | 开发难易程度 |
| --------------- | ---------- | ------------ | ------------ | ------------ |
| JDK 的TimeTask  | 不支持     | 支持         | 支持         | 复杂         |
| Spring Schedule | 支持       | 支持         | 支持         | 简单         |
| Quartz          | 支持       | 支持         | 支持         | 难           |

### springTask与quartz比较

**Quartz 特点：**

- 默认多线程异步执行
- 一个任务在上一次调度未完成执行，下一次调度时间到时，会另起一个线程开始新的调度。在业务繁忙时，一个任务或许会有多个线程在执行，导致数据处理异常。
- 单任务同步：配置属性，可以使一个任务的一次调度在未完成时，而不会开启下一次调度
- 多个任务同时运行，任务之间没有直接的影响，多任务执行的快慢取决于CPU的性能
- 支持集群部署

集群通过故障切换和负载平衡的功能，能给调度器带来高可用性和伸缩性。

从本质上来说，是使集群上的每一个节点通过共享同一个数据库来工作的（Quartz通过启动两个维护线程来维护数据库状态实现集群管理，一个是检测节点状态线程，一个是恢复任务线程）。

负载平衡是自动完成的，集群的每个节点会尽快触发任务。当一个触发器的触发时间到达时，第一个节点将会获得任务（通过锁定），成为执行任务的节点。

故障切换的发生是在当一个节点正在执行一个或者多个任务失败的时候。当一个节点失败了，其他的节点会检测到并且标 识在失败节点上正在进行的数据库中的任务。任何被标记为可恢复（任务详细信息的”requests recovery”属性）的任务都会被其他的节点重新执行。没有标记可恢复的任务只会被释放出来，将会在下次相关触发器触发时执行。

**Spring Task特点：**

spring-task，可以将它比作一个轻量级的Quartz，而且使用起来很简单，除spring相关的包外不需要额外的包，而且支持注解和配置文件两种形式

- 默认单线程同步执行
- 一个任务执行完上一次之后，才会执行下一次调度 spring task的**调度任务是串行的，**意思就是如果配了多个任务的话，**前面一个任务没有结束，后面的任务即使是时间到点了也不会跑**
- 多任务之间按顺序执行，一个任务执行完成之后才会执行另一个任务
- 多任务并行执行需要设置线程池
- 全程可以通过注解配置
- 不支持分布式部署 不支持持久化，如果项目需要持久化定时任务，还是要选择Quartz比较

**两者对异常的处理**

- Quartz的某次执行任务过程中抛出异常，不影响下一次任务的执行，当下一次执行时间到来时，定时器会再次执行任务。
- SpringTask不同，一旦某个任务在执行过程中抛出异常，则整个定时器生命周期就结束，以后永远不会再执行定时器任务

### xxljob和elasticjob比较

共同点： E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。
不同点：
X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用
E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用

**支持集群部署**

*X-Job*　：　集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。

> 执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses/调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。

*E-Job*　：　重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心

> 作业注册中心： 基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。

最新版本X-job 基于时间轮，使用数据库实现注册中心，E-Job 基于 quartz，改用Zookeeper实现注册中心

**多节点部署时任务不能重复执行**

*X-Job*　：　使用Quartz基于数据库的分布式功能
*E-Job*　 ：　将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。

**日志可追溯**

*X-Job*　：　支持，有日志查询界面
*E-Job*　：　可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。

**监控告警**

*X-Job*　：　调度失败时，将会触发失败报警，如发送报警邮件。

> 任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔

*E-Job*　：　通过事件订阅方式可自行实现

> 作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。）

**弹性扩容缩容**

*X-Job*　：　使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力
*E-Job*　：　通过zk实现各服务的注册、控制及协调

**支持并行调度**

*X-Job*　：　调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。
*E-Job*　：　采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。

**高可用策略**

*X-Job*　：　“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；
*E-Job*　：　调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。

**失败处理策略**

*X-Job*　：　调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；
*E-Job*　：　弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。

**动态分片策略**

*X-Job*　：　分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。

> 执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；

*E-Job*　：　支持多种分片策略，可自定义分片策略

> 默认包含三种分片策略： 基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略
>
> elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：
> a、新的Job实例加入集群
> b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行）
> c、主节点选举”

而 xxl-job的是通过一个中心式集群"调度中心”来调度多个执行器执行任务的，调度中心集群可以通过增加机器来实现高可用（HA）实际会造成一定程度上的资源浪费，调度中心通过DB锁保证集群分布式调度的一致性，这样扩展执行器会增大DB的压力，但是如果实际上这里数据库只是负责任务的调度执行。在没有那么多数量的执行器和任务的情况下是完全没问题的。执行器可以支持分布式部署，这实际上就足以满足大多数场景了。关键是原理简单实现也非常简洁，用起来也很轻便，与springboot也非常好集成。而且他的监控界面直接集成到调度中心里面，可以在监控界面直接新增任务，使用GLUE模式甚至可以直接在监控界面上做任务开发写业务代码，这点未必用得到，但是确实很方便；而elastic-job是一个单独的工程连到zk上去监控的，因此不能直接增新增任务，也不能停止执行中的任务。单独记录执行日志到数据库，然后很方便的统一管理和重发，还有失败的邮件提醒都是简单又好用的功能，对于一些常规的定时任务来说感觉应该用起来很舒服。

  综合来说，xxl-job在我看来在业务量没那么大的时候是一个更好的选择。